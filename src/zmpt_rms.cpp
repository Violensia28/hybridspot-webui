#include "zmpt_rms.h"
bool ZmptRms::begin(uint8_t pin,float vps,uint32_t fs,uint16_t win){ pin_=pin; v_per_step_=vps; fs_=fs?fs:2000; win_ms_=win?win:20; Ts_us_=(uint32_t)(1000000UL/fs_); uint32_t Nc=(fs_*win_ms_)/1000; if(Nc<4) Nc=4; if(Nc>MAXN) Nc=MAXN; N_=(uint16_t)Nc; head_=0; filled_=false; sum_=sum2_=0; x_prev_=y_prev_=0; vrms_lpf_=0; next_us_=micros()+Ts_us_; return true; }
void ZmptRms::push(int32_t y){ if(filled_){ int32_t old=ring_[head_]; sum_-=old; sum2_-=(double)old*old;} ring_[head_]=y; sum_+=y; sum2_+=(double)y*y; head_++; if(head_>=N_){ head_=0; filled_=true;} uint16_t cnt=filled_?N_:head_; if(cnt>=2){ double mean=sum_/cnt; double var=(sum2_/cnt)-(mean*mean); if(var<0)var=0; float vrms_i=(float)(sqrt(var)*v_per_step_); vrms_lpf_ += a_lpf_*(vrms_i - vrms_lpf_);} }
void ZmptRms::tick(){ uint32_t now=micros(); if((int32_t)(now-next_us_)<0) return; do{ int32_t x=analogRead(pin_); int32_t y=(int32_t)(a_hpf_*((float)y_prev_ + (float)(x - x_prev_))); x_prev_=x; y_prev_=y; push(y); next_us_+=Ts_us_; }while((int32_t)(now-next_us_)>=0);} 
